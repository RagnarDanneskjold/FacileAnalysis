% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/fdge-compare.R, R/fdge-interact.R, R/fdge.R
\name{compare.FacileTtestAnalysisResult}
\alias{compare.FacileTtestAnalysisResult}
\alias{report.FacileTtestAnalysisResult}
\alias{fdge}
\alias{fdge.FacileAnovaModelDefinition}
\alias{fdge.FacileDgeModelDefinition}
\title{Peform a differential expression analysis.}
\usage{
\method{compare}{FacileTtestAnalysisResult}(x, y, ...)

\method{report}{FacileTtestAnalysisResult}(x, type = c("dge",
  "features"), ntop = 200, max_padj = 0.1, min_logFC = 1,
  features = NULL, round_digits = 3, event_source = "A",
  webgl = TRUE, caption = NULL, ...)

fdge(x, ...)

\method{fdge}{FacileAnovaModelDefinition}(x, assay_name = NULL,
  method = NULL, filter = "default", with_sample_weights = FALSE,
  ...)

\method{fdge}{FacileDgeModelDefinition}(x, assay_name = NULL,
  method = NULL, filter = "default", with_sample_weights = FALSE,
  treat_lfc = NULL, ...)
}
\arguments{
\item{x}{a data source}

\item{...}{passed down into inner methods, such as \code{biocbox} to tweak
filtering criteria, for instance}

\item{assay_name}{the name of the assay that holds the measurements for test.
Defaults to \code{default_assay(x)}.}

\item{method}{The differential testing framework to use over the data. The
valid choices are defined by the type of assay \code{assay_name}is. Refer to the
\emph{Differential Expression Testing Methods} section for more details.}

\item{filter, with_sample_weights}{Passed into \code{\link[=biocbox]{biocbox()}} to determine which
features (genes) are removed from the dataset for testing, as well as if
to use \code{\link[limma:arrayWeights]{limma::arrayWeights()}} or \code{\link[limma:voomWithQualityWeights]{limma::voomWithQualityWeights()}}
(where appropriate) when testing (default is not to).}
}
\description{
Use \code{\link[=fdge_model_def]{fdge_model_def()}} to define the design matrix and contrast to test and
pass the \code{FacileDgeModelDefinition} object returned from that to \code{fdge()}
to run the desired differential testing framework (dictated by the \code{method}
parameter) over the data. \code{fdge_model_def} accepts a
}
\section{Comapring DGE Results}{

We can compare two Ttest results.

The filtering strategy in the interaction model dictates that the union
of all features found in \code{x} are \code{y} are used in the test.
}

\section{Interacting with results}{


The \code{report} function will create an htmlwidget which can be explored by
the analyst or dropped into an Rmarkdown report.

\code{report(result, "dge", max_padj = 0.05, min_logFC = 1)} will create a
side-by-side volcano and datatable for differential expression results.
}

\section{Differential Expression Testing Methods}{

The appropriate statistical framework to use for differential expression
testing is defined by the type of data that is recorded in the assay
\code{assay_name}, ie. \code{assay_info(x, assay_name)$assay_type}.

The \code{fdge_methods()} function returns a tibble of appropriate
\code{assay_type -> dge_method} associations. The first entry for each
\code{dge_method} is the default \code{method} used if one isn't provided by the
caller.

The available methods are:
\itemize{
\item \code{"voom"}: For count data, uses \code{\link[limma:voomWithQualityWeights]{limma::voomWithQualityWeights()}} when
\code{with_sample_weights = TRUE}.
\item \code{"edgeR-qlf"}: The edgeR quasi-likelihood method, for count data.
\item \code{"limma-trend"}: Usable for log-transformed data that "looks like" it came
from count data, or where there is a "trend" of the variance with the
mean, uses  \code{\link[lima:arrayWeights]{lima::arrayWeights()}} when \code{with_sample_weights = TRUE}.
\item \code{"limma"}: Straightup limma, this expects log2-normal like data, with
(largely) no trend of the variance to the mean worth modeling. Uses
\code{\link[lima:arrayWeights]{lima::arrayWeights()}} when \code{with_sample_weights = TRUE}
}
}

\section{Feature Filtering Strategy}{

You will almost always want to filter out lowly abundant features before
performing differential expression analysis. For this reason, when the
\code{filter} parameter is set to \code{"default"}, the filtering strategy is largely
is largely based on the logic found in \code{\link[edgeR:filterByExpr]{edgeR::filterByExpr()}}.

When \code{fdge} analysis is perfomd on count data, the filtering is precisely
perfomed by this function, using \code{design(x)} as the design paratmer to
\code{filterByExpr}. You can modify the filtering behavior by passing any
named parameters found in the \code{\link[edgeR:filterByExpr]{edgeR::filterByExpr()}} function down to it via
\code{fdge}'s \code{...} parameter (don't pass \code{design}, as this is already defined).

There are times when you want to tweak this behavior in ways that aren't
exactly supported by \code{filterByExpr}. You can pass in a "feature descriptor"
(a character vector of feature ids, or a data.frame with a "feature_id"
column) into the following parameters:
\itemize{
\item \code{filter_universe}: The features enumerated in this parameter will restrict
the universe of features that can potentially be included in the downstream
analysis. The \code{filterByExpr()} logic will happen downstream of this
universe. The default value is \code{NULL}, which specifies the universe of
features to be all of the ones measured using this assay.
\item \code{filter_require}: The \code{filterByExpr} logic happens first on the universe
of features as parameterized. All features enumerated here will be forcibly
included in the analysis, regardless of their expression levels. The
defalut value is \code{NULL}, which means no genes will be "recovered" if they
don't pass "filter muster".
\item \code{filter}: If a feature descriptor is provided here, then only the features
enumerated here (that were assayed) will be included in the analysis.
}
}

\examples{
# Comparing two T-test results ----------------------------------------------
# Let's compare the tumor vs normal DGE results in CRC vs BLCA

efds <- exampleFacileDataSet()
dge.crc <- filter_samples(efds, indication == "CRC") \%>\%
  fdge_model_def("sample_type", "tumor", "normal", "sex") \%>\%
  fdge()
dge.blca <- filter_samples(efds, indication == "BLCA") \%>\%
  fdge_model_def("sample_type", "tumor", "normal", "sex") \%>\%
  fdge()
dge.comp <- compare(dge.crc, dge.blca)
if (interactive()) {
  report(dge.comp)
  shine(dge.comp)
}
efds <- FacileData::exampleFacileDataSet()
samples <- FacileData::filter_samples(efds, indication == "BLCA")
mdef <- fdge_model_def(samples, covariate = "sample_type",
                       numer = "tumor", denom = "normal", batch = "sex")
dge <- fdge(mdef, method = "voom")
if (interactive()) {
  viz(dge)
  shine(dge)
}
dge.stats <- tidy(dge)
dge.sig <- signature(dge)

stage.anova <- samples \%>\%
  fdge_model_def(covariate = "stage", batch = "sex") \%>\%
  fdge(method = "voom")
anova.sig <- signature(stage.anova)
}
