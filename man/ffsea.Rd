% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/ffsea.R
\name{ffsea}
\alias{ffsea}
\alias{result.FacileFseaAnalysisResult}
\title{Performs Feature (Gene) Set Enrichment Analyses}
\usage{
ffsea(x, ...)

\method{result}{FacileFseaAnalysisResult}(x, name = "object", ...)
}
\arguments{
\item{x}{A \code{FacileAnalysisResult} object}

\item{gdb}{A \code{multiGSEA::GeneSetDb} object}

\item{methods}{the GSEA methods to use on \code{x}.}
}
\value{
A FacileGSEAResult object, which includes a MultiGSEAResult object
as it's \code{result()}.
}
\description{
\strong{For now} only GSEA methods process a pre-ranked feature set work, like
\code{"cameraPR"} and \code{"fgsea"}.
}
\details{
The default method run is simply \code{"cameraPR"}.
}
\section{Updates required to multiGSEA}{

I need to update multiGSEA to take an input data.frame of differential
expression statistics to work with goseq as well such that it doesn't have to
run the differential expression stuff again.

Once this is implemented, the a call to \code{ffsea} will also work on an Anova
result, as well.
}

\section{Accessing Results}{

We are in a bit of a schizophrenic state right now, where \code{tidy()} is
being the de-facto way to answer "tidy" like results (instead of result()).

This is not to say that \code{result()} can't also return something that's
"tidy", but in this case, result(ffsea.result) will return the
MultiGSEAResult object itself, and \code{tidy(ffsea.result)} will dispatch
to \code{\link[multiGSEA:result]{multiGSEA::result()}} to fetch the gsea statistcs for the method
requested.\preformatted{mgres <- result(ffsea.res) # return the MultiGSEAResult object
camera.stats <- tidy(ffsea.res, name = "cameraPR")
}
}

\examples{
gdb <- multiGSEA::getMSigGeneSetDb("h", "human", id.type = "entrez")
efds <- FacileData::exampleFacileDataSet()

# GSEA from t-test result ---------------------------------------------------
ttest.res <- efds \%>\%
  FacileData::filter_samples(indication == "CRC") \%>\%
  fdge_model_def(covariate = "sample_type",
                 numer = "tumor", denom = "normal", batch = "sex") \%>\%
  fdge(method = "voom")
ttest.gsea <- ffsea(ttest.res, gdb, methods = c("cameraPR", "fgsea"))
if (interactive()) {
  shine(ttest.gsea)
}

mgsea.result <- result(ttest.gsea)
camera.stats <- tidy(ttest.gsea, "cameraPR")
fgsea.stats <- tidy(ttest.gsea, "fgsea")

# GSEA from ANOVA result ----------------------------------------------------
\dontrun{
# This requires an update in mutiGSEA (to support df inputs) to run
stage.anova <- efds \%>\%
  FacileData::filter_samples(indication == "BLCA") \%>\%
  fdge_model_def(covariate = "stage", batch = "sex") \%>\%
  fdge(method = "voom")
anova.gsea <- ffsea(stage.anova)
if (interactive()) {
 shine(anova.gsea)
}
}

# GSEA over loadings on a Principal Component -------------------------------
pca.crc <- efds \%>\%
  FacileData::filter_samples(indication == "CRC") \%>\%
  fpca()
pca1.gsea <- ffsea(pca.crc, gdb, dim = 1)

# Not yet implemented, need to get a signed weight out of eigenWeightedMean
# right now we just have weights. Or, fully extracing the biplot code, I
# think the weight should be the length on the PC of choice, and the sign is
# the same.
}
